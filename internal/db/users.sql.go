// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: users.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignUserRole = `-- name: AssignUserRole :exec
INSERT INTO user_roles (
    user_id,
    role_id
) VALUES (
             $1, $2
         )
`

type AssignUserRoleParams struct {
	UserID int64 `json:"user_id"`
	RoleID int64 `json:"role_id"`
}

func (q *Queries) AssignUserRole(ctx context.Context, arg AssignUserRoleParams) error {
	_, err := q.db.Exec(ctx, assignUserRole, arg.UserID, arg.RoleID)
	return err
}

const checkUserLoginExists = `-- name: CheckUserLoginExists :one
SELECT EXISTS(
    SELECT 1 FROM users WHERE login = $1
) AS exists
`

func (q *Queries) CheckUserLoginExists(ctx context.Context, login string) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserLoginExists, login)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countUsers = `-- name: CountUsers :one
SELECT COUNT(DISTINCT u.id)
FROM users u
WHERE
    ($1::bigint IS NULL OR u.organization_id = $1) AND
    (
        $2 = '' OR
        u.login ILIKE $2 OR
        u.name ILIKE $2 OR
        u.surname ILIKE $2
        )
`

type CountUsersParams struct {
	Column1 int64       `json:"column_1"`
	Column2 interface{} `json:"column_2"`
}

func (q *Queries) CountUsers(ctx context.Context, arg CountUsersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countUsers, arg.Column1, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    login,
    password,
    name,
    surname,
    patronymic,
    organization_id,
    created_at,
    updated_at
) VALUES (
             $1, $2, $3, $4, $5, $6,
             CURRENT_TIMESTAMP,
             CURRENT_TIMESTAMP
         )
RETURNING id, login, password, name, surname, patronymic, organization_id, created_at, updated_at
`

type CreateUserParams struct {
	Login          string  `json:"login"`
	Password       string  `json:"password"`
	Name           *string `json:"name"`
	Surname        *string `json:"surname"`
	Patronymic     *string `json:"patronymic"`
	OrganizationID int64   `json:"organization_id"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Login,
		arg.Password,
		arg.Name,
		arg.Surname,
		arg.Patronymic,
		arg.OrganizationID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Login,
		&i.Password,
		&i.Name,
		&i.Surname,
		&i.Patronymic,
		&i.OrganizationID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const deleteUserRoles = `-- name: DeleteUserRoles :exec
DELETE FROM user_roles
WHERE user_id = $1
`

func (q *Queries) DeleteUserRoles(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, deleteUserRoles, userID)
	return err
}

const deleteUserSessions = `-- name: DeleteUserSessions :exec
DELETE FROM sessions
WHERE user_id = $1
`

func (q *Queries) DeleteUserSessions(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, deleteUserSessions, userID)
	return err
}

const getUser = `-- name: GetUser :one
SELECT u.id, u.login, u.password, u.name, u.surname, u.patronymic, u.organization_id, u.created_at, u.updated_at, array_agg(r.name) as roles
FROM users u
         LEFT JOIN user_roles ur ON u.id = ur.user_id
         LEFT JOIN roles r ON ur.role_id = r.id
WHERE u.id = $1
GROUP BY u.id
`

type GetUserRow struct {
	ID             int64            `json:"id"`
	Login          string           `json:"login"`
	Password       string           `json:"password"`
	Name           *string          `json:"name"`
	Surname        *string          `json:"surname"`
	Patronymic     *string          `json:"patronymic"`
	OrganizationID int64            `json:"organization_id"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
	Roles          interface{}      `json:"roles"`
}

func (q *Queries) GetUser(ctx context.Context, id int64) (GetUserRow, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i GetUserRow
	err := row.Scan(
		&i.ID,
		&i.Login,
		&i.Password,
		&i.Name,
		&i.Surname,
		&i.Patronymic,
		&i.OrganizationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Roles,
	)
	return i, err
}

const getUserRoles = `-- name: GetUserRoles :many
SELECT r.id, r.name, r.description
FROM roles r
         JOIN user_roles ur ON r.id = ur.role_id
WHERE ur.user_id = $1
`

func (q *Queries) GetUserRoles(ctx context.Context, userID int64) ([]Role, error) {
	rows, err := q.db.Query(ctx, getUserRoles, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Role
	for rows.Next() {
		var i Role
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT u.id, u.login, u.password, u.name, u.surname, u.patronymic, u.organization_id, u.created_at, u.updated_at, array_agg(r.name) as roles
FROM users u
         LEFT JOIN user_roles ur ON u.id = ur.user_id
         LEFT JOIN roles r ON ur.role_id = r.id
WHERE
    ($1::bigint IS NULL OR u.organization_id = $1) AND
    (
        $2 = '' OR
        u.login ILIKE $2 OR
        u.name ILIKE $2 OR
        u.surname ILIKE $2
        )
GROUP BY u.id
ORDER BY u.created_at DESC
LIMIT $3 OFFSET $4
`

type ListUsersParams struct {
	Column1 int64       `json:"column_1"`
	Column2 interface{} `json:"column_2"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type ListUsersRow struct {
	ID             int64            `json:"id"`
	Login          string           `json:"login"`
	Password       string           `json:"password"`
	Name           *string          `json:"name"`
	Surname        *string          `json:"surname"`
	Patronymic     *string          `json:"patronymic"`
	OrganizationID int64            `json:"organization_id"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
	Roles          interface{}      `json:"roles"`
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]ListUsersRow, error) {
	rows, err := q.db.Query(ctx, listUsers,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersRow
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Login,
			&i.Password,
			&i.Name,
			&i.Surname,
			&i.Patronymic,
			&i.OrganizationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Roles,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET
    name = COALESCE($2, name),
    surname = COALESCE($3, surname),
    patronymic = COALESCE($4, patronymic),
    password = COALESCE($5, password),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, login, password, name, surname, patronymic, organization_id, created_at, updated_at
`

type UpdateUserParams struct {
	ID         int64   `json:"id"`
	Name       *string `json:"name"`
	Surname    *string `json:"surname"`
	Patronymic *string `json:"patronymic"`
	Password   string  `json:"password"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.ID,
		arg.Name,
		arg.Surname,
		arg.Patronymic,
		arg.Password,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Login,
		&i.Password,
		&i.Name,
		&i.Surname,
		&i.Patronymic,
		&i.OrganizationID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserLastLogin = `-- name: UpdateUserLastLogin :exec
UPDATE users
SET last_login = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) UpdateUserLastLogin(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, updateUserLastLogin, id)
	return err
}
